class Matrix:
    def __init__(self, data, n=None):
        if isinstance(data, list):  # Initialize with list of lists
            self.matrix = data
            self.rows = len(data)
            self.cols = len(data[0]) if data else 0
        elif isinstance(data, int) and isinstance(n, int):  # Initialize with dimensions m x n
            self.rows = data
            self.cols = n
            self.matrix = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
        else:
            raise ValueError("Invalid initialization format")

    def shape(self):
        return (self.rows, self.cols)
    
    def transpose(self):
        transposed = [[self.matrix[j][i] for j in range(self.rows)] for i in range(self.cols)]
        return Matrix(transposed)
    
    def row(self, n):
        if n >= self.rows:
            raise IndexError("Row index out of range")
        return self.matrix[n]

    def column(self, n):
        if n >= self.cols:
            raise IndexError("Column index out of range")
        return [self.matrix[i][n] for i in range(self.rows)]
    
    def to_list(self):
        return self.matrix
    
    def block(self, m_0, n_0, m_1, n_1):
        return [row[n_0:n_1] for row in self.matrix[m_0:m_1]]
    
    def __getitem__(self, idx):
        return self.matrix[idx]
    
    # Scalar multiplication
    def scalar_mult(self, c):
        return Matrix([[self.matrix[i][j] * c for j in range(self.cols)] for i in range(self.rows)])
    
    # Matrix addition
    def mat_add(self, other):
        if self.shape() != other.shape():
            raise ValueError("Matrices must have the same dimensions to add")
        return Matrix([[self.matrix[i][j] + other[i][j] for j in range(self.cols)] for i in range(self.rows)])
    
    # Matrix subtraction
    def mat_sub(self, other):
        if self.shape() != other.shape():
            raise ValueError("Matrices must have the same dimensions to subtract")
        return Matrix([[self.matrix[i][j] - other[i][j] for j in range(self.cols)] for i in range(self.rows)])

    # Matrix multiplication
    def mat_mult(self, other):
        if self.cols != other.shape()[0]:
            raise ValueError("Number of columns of the first matrix must equal the number of rows of the second")
        result = [[sum(self.matrix[i][k] * other[k][j] for k in range(self.cols)) for j in range(other.shape()[1])] for i in range(self.rows)]
        return Matrix(result)

    # Element-wise multiplication
    def element_mult(self, other):
        if self.shape() != other.shape():
            raise ValueError("Matrices must have the same dimensions for element-wise multiplication")
        return Matrix([[self.matrix[i][j] * other[i][j] for j in range(self.cols)] for i in range(self.rows)])

    # Matrix equality check
    def mat_equals(self, other):
        return self.shape() == other.shape() and all(self.matrix[i][j] == other[i][j] for i in range(self.rows) for j in range(self.cols))


# Test operations
m1 = Matrix([[1, 2], [3, 4]])
m2 = Matrix([[5, 6], [7, 8]])

# Testing scalar multiplication, addition, subtraction, and multiplication
scalar_mult_result = m1.scalar_mult(2).to_list()
add_result = m1.mat_add(m2).to_list()
sub_result = m1.mat_sub(m2).to_list()
mult_result = m1.mat_mult(m2).to_list()
element_mult_result = m1.element_mult(m2).to_list()

scalar_mult_result, add_result, sub_result, mult_result, element_mult_result
